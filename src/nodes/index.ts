

import { SpotifyApi } from "@spotify/web-api-ts-sdk";
import { AppNode } from "./types";

const addTracksToSpotifyPlaylist = async (spotifySdk : SpotifyApi, playlistName : string, tracks : any) => {
  try {
      const userId = (await spotifySdk.currentUser.profile()).id;
      const myPlaylists = await spotifySdk.playlists.getUsersPlaylists(userId);
      let playlist = myPlaylists.items.find((pl) => pl.name === playlistName);

      if (!playlist) {
          playlist = await spotifySdk.playlists.createPlaylist(userId, {name: playlistName, description: 'Generated by Gumloop', public: true});
      }

      const playlistId = playlist.id;

      
      if (tracks.length > 0) {
          const uris = tracks.map((track: any) => track.spotifyTrackUri);
          await spotifySdk.playlists.addItemsToPlaylist(playlistId, uris);
      } else {
          throw new Error('No tracks provided to add to the playlist');
      }
  } catch (error) {
      console.error('Error adding tracks to Spotify playlist:', error);
      throw error;
  }
}


const getSpotifyTracks = async (spotifySdk: SpotifyApi, tracks: any) => {
  try {
    const result = [];
    
    for (const track of tracks) {
      const { title, artist, album } = track;

      // if album is null then search with track and artist. same with artist and track
      let query = "";

      if (title) {
        query += `track:${title} `;
      }
      if (artist) {
        query += `artist:${artist} `;
      }
      if (album) {
        query += `album:${album}`;
      }
      query = query.trim();

      // const query = `${track ? "track:" + track : ''} ${artist ? "artist:" + artist : ''} ${album ? "album:" + album : ''}`;

      const response = await spotifySdk.search(query, ['track'], 'US', 1);

      if (response?.tracks?.items?.length > 0) {
        const spotifyTrack = response.tracks.items[0];
        console.log('Spotify Track:', spotifyTrack);
        result.push({
          title: track.title,
          artist: track.artist,
          album: track.album,
          time: track.time,
          spotifyTrackId: spotifyTrack.id,
          spotifyTrackUri: spotifyTrack.uri,
          spotifyTrackName: spotifyTrack.name,
          spotifyArtist: spotifyTrack.artists.map((a: any) => a.name).join(', '),
          spotifyAlbum: spotifyTrack.album.name,
        });
      } else {
        console.warn(`No match found for track: ${title} by ${artist}`);
      }
    }

    return result;
  } catch (error) {
    console.error('Failed to fetch Spotify playlist:', error);
    throw error;
  }
};


const fetchAndProcessHtml = async (inputType: string, input: string) => {
  try {
    if (inputType === "playlistId") {
      const fetchPlayListURL = import.meta.env.VITE_FETCH_PLAYLIST_URL + input;
      console.log('Playlist URL:', fetchPlayListURL);
      if (!fetchPlayListURL || fetchPlayListURL === '') {
        console.error('Playlist ID is null or undefined.');
        return;
      }
      const response = await fetch(fetchPlayListURL);

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const html = await response.text();
      return getTrackDetails(html);
    }
    else{
      return getTrackDetails(input);
    }
  } catch (error) {
    console.error('Failed to fetch HTML:', error);
    throw error;
  }
}

const getTrackDetails = (html: string) => {
  // TODO - we can modify this to be more robust using AI to extract the details rather than just parsing the HTML
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");

  const items = doc.querySelectorAll("ytmusic-responsive-list-item-renderer");
  const details = Array.from(items).map((item) => {
    const formattedStrings = item.querySelectorAll(
      "yt-formatted-string[title]"
    );
    return {
      // this is for non-collobrated playlist (i.e. individual playlist)
      title: formattedStrings[0]?.getAttribute("title") || null, // Main title
      artist: formattedStrings[1]?.getAttribute("title") || null, // Artist
      album: formattedStrings[2]?.getAttribute("title") || null, // Album
      time: formattedStrings[3]?.getAttribute("title") || null, // Time
    };
  });

  console.log("Extracted Details:", details);
  return details;
};

const convertToCSV = (data: any) => {
  const headers = Object.keys(data[0]).join(",") + "\n";
  const rows = data.map((row: any) =>
    Object.values(row).map((value) => `"${value}"`).join(",")
  ).join("\n");
  return headers + rows;
};


export const initialNodes: AppNode[] = [
  {
    id: "custom-1",
    type: "custom-input-node",
    position: { x: 1224, y: -320 },
    data: {
      label: "Text Node",
      description: "Takes an input - playlist id.",
      output: [
        {
          name: "playlistId",
          value: "PLgBV6dl98LOFDeCAT_guiQAzVRhPJfLMi",
        },
        {
          name: "htmlContent",
          value: "",
        }
      ]
    }
  },
  {
    id: "custom-2",
    type: "youtube-node",
    position: { x: 1224, y: 56 },
    data: {
      label: "Youtube Node",
      description: "Get playlist details from youtube",
      output: [
        {
          name: "tracks",
          value: [],
        }
      ],
      execute: async (_id : string, inputType : string, input : string) => {
        try {
          return await fetchAndProcessHtml(inputType, input);
        }
        catch (error) {
          console.error('Failed to fetch HTML:', error);
          throw error;
        }
      }
    }
  },
  {
    id: "custom-3",
    type: "spotify-input-node",
    position: { x: 732, y: 86 },
    data: {
      label: "Spotify Access Node",
      description: "Get playlist details from youtube",
      bearerToken: ""
    }
  },
  {
    id: "custom-4",
    type: "output-node",
    position: { x: 992, y: 1109 },
    data: {
      label: "Save Output Node",
      outputFileName: "",
      execute: (id, _outputFileName, value) => {
        console.log(`Node ${id} input changed to:`, value);
        const data = convertToCSV(value);
        if(data === '') {
          console.error('No data to save.');
          throw new Error('No data to save.');
        }
        const blob = new Blob([data], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        return url;
      },
    }
  },
  {
    id: "custom-5",
    type: "spotify-search-track-node",
    position: { x: 1148, y: 378 },
    data: {
      label: "Spotify Search Track Node",
      description: "Search for tracks on Spotify",
      output: [
        {
          name: "tracks",
          value: [],
        }
      ],
      execute: async (_id : string, spotifySdk : any, tracks : any) => {
        return await getSpotifyTracks(spotifySdk, tracks).then((data) => {
          console.log('Data:', data);
          // found tracks list
          return data;
        });
      }
    }
  },
  {
    id: "custom-6",
    type: "spotify-create-track-node",
    position: { x: 812, y: 666 },
    data: {
      label: "Spotify Create Playlist Node",
      description: "Search for tracks on Spotify",
      playlistName: "Gumloop Playlist",
      output: [
        {
          name: "tracks",
          value: [],
        }
      ],
      execute: async (_id : string, spotifySdk : any, playlistName : string, tracks : any) => {
        await addTracksToSpotifyPlaylist(spotifySdk, playlistName, tracks);
        return tracks;
      }
    }
  }
];


